# Контракт поведения распределённого/хранимого кэша

Microsoft в своей стандартной библиотеке .NET предлагает контракт распределённого кэша [`IDistributedCache`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache?view=net-9.0-pp) и его дальнейшее развитие с прицелом на производительность [`IBufferDistributedCache`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.distributed.ibufferdistributedcache?view=net-9.0-pp). К сожалению, Microsoft предлагает только контракт интерфейса, но плохо, или лучше сказать “почти никак”, не формализует контракт поведения. Мне пришлось восстанавливать контракт поведения на основе двух конкретных реализаций [`SqlServerCache`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.sqlserver.sqlservercache?view=net-10.0-pp&viewFallbackFrom=net-9.0-pp) и [`RedisCache`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.stackexchangeredis.rediscache?view=net-10.0-pp&viewFallbackFrom=net-9.0-pp). Возможно, я что-то понял неправильно, но, тем не менее, это лучше, чем ничего. На основе своего понимания, я создал абстракции, которые реализуют данный контракт поведения и оставляют на откуп конкретных реализаций только вопросы взаимодействия с хранилищем. Для примера можно посмотреть [мои реализации распределённого кэша на основе объектного и key/value хранилищ NATS](https://github.com/Eshva/Eshva.Caching.Nats).

## Требования к ключам и значениям элементов кэша

- Доступ к элементу осуществляется по его ключу.
- Ключ является обязательным и представляет собой непустую строку, состоящую не только из пробельных символов.
- Удаление пробельных символов в начале и конце ключа не производится.
- Ключи в кэше должны быть уникальными.
- Значение всегда представляет собой массив байт.
- Значение элемента не может отсутствовать, то есть не может быть установлено в `null`.
- Конкретные реализации могут накладывать ограничения на ключ элемента кэша. Например, key/value хранилище NATS накладывает ограничения на специальные знаки, которые могут встречаться в ключе.
- Конкретные реализации, а также настройки хранилища конкретной реализации, могут накладывать свои ограничения на максимальный размер значения элемента.

## Устаревание элементов кэша

- Это кэш с инвалидацией элементов по времени.
- С каждым элементом кэша должны быть связаны параметры его устаревания: момент устаревания, абсолютное устаревание, плавающее устаревание. Они являются его метаданными.
- Абсолютное устаревание определяет момент времени, иными словами дату/время.
- Плавающее устаревание определяет интервал времени жизни элемента от последнего его получения или принудительного обновления.
- Абсолютное и/или плавающее устаревание можно определить в момент создания нового элемента или в момент обновления имеющегося.
- Если при создании элемента не было указано ни абсолютное, ни плавающее устаревание, элементу назначается плавающее устаревание с продолжительностью по умолчанию (определяется при создании кэша, лучше выносить в настройки приложения).
- Если элемент уже устарел, он не может быть возвращён и должен быть удалён.
- Абсолютное устаревание имеет приоритет над плавающим, то есть, если запись устарела с точки зрения абсолютного устаревания, элемент должен быть удалён.
- Момент устаревания элемента может быть обновлён, только если для элемента настроено плавающее устаревание.

## Инвалидация кэша

- Инвалидация кэша предполагает удаление всех просроченных элементов.
- Инвалидация кэша имеет шанс быть выполненной при вызове любого метода контракта интерфейса кэша.
- Для целей оптимизации инвалидация кэша запускается не чаще определённого интервала, например 1 минуты. Этот интервал должен быть определён конкретной реализацией кэша.
- Одновременно может выполняться только одна ивалидация.
- Инвалидация кэша может запускаться по таймеру или только в момент обращения к кэшу. Мной выбран последний подход, как более простой, бережливый и надёжный.
- Инвалидация кэша выполняется в фоновом режиме, чтобы не тормозить операцию доступа, её запустившую.

## Ошибки работы с кэшем

К сожалению, Microsoft не определяет контракт сообщения о возможных ошибках в описании методов интерфейсов распределённого кэша кроме самых базовых, вроде [`OperationCanceledException`](https://learn.microsoft.com/en-us/dotnet/api/system.operationcanceledexception?view=net-10.0-pp) или [`ArgumentException`](https://learn.microsoft.com/en-us/dotnet/api/system.argumentexception?view=net-10.0-pp). А они могут возникнуть. Например, что нужно сделать, если в качестве ключа элемента передана пустая строка? Или какое исключение нужно выбросить, если хранилище кэша стало недоступным? Методы кэша не должны выбрасывать исключения, специфичные для конкретной реализации, чтобы не допустить протекания абстракции (к сожалению, по крайней мере, в конкретных реализациях Microsoft это не так). Мне пришлось самостоятельно определить контракт сообщения об ошибках и выбрать исключения, связанные с аргументами, и `InvalidOperationException` для всего остального.

- Об ошибках, связанных с аргументами, в зависимости от контекста, сообщать с помощью наиболее подходящих исключений, связанных с аргументами: `ArgumentNullException`, `ArgumentException`, `ArgumentOutOfRangeException`.
- О прочих ошибках, например, недоступности хранилища кэша, сообщать с помощью `InvalidOperationException`.
- Удаление ранее удалённого, в силу устаревания или непосредственного удаления, элемента не должно приводить к ошибкам.
- Получение значения несуществующего, ранее удалённого или устаревшего элемента не должно приводить к ошибкам.
- Обновление момента устаревания несуществующего, ранее удалённого или устаревшего элемента не должно приводить к ошибкам.