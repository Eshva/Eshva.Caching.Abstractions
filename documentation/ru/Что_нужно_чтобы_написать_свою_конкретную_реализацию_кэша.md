# Что нужно, чтобы написать свою конкретную реализацию кэша

Чтобы написать свою конкретную реализацию кэша, например, использующую какую-то базу данных, необходимо реализовать всего 2 класса:

1. Хранилище кэша, реализующего интерфейс `ICacheDatastore`. Как следует из названия реализует взаимодействие методов кэша с конкретным хранилищем.
2. Инвалидацию кэша, наследующей абстрактный класс `TimeBasedCacheInvalidation`. Также взаимодействует с конкретным хранилищем с целью получения всех устаревших элементов и их удаления.

## Хранилище кэша

Контракт поведения методов описан в их документации непосредственно в исходном коде, отдельно добавить нечего.

TODO: Написать абстрактные тесты для проверки выполнения контракта поведения.

## Инвалидация кэша

Класс-наследник должен реализовать единственный метод `DeleteExpiredCacheEntries`, всё остальное сделает базовый класс `TimeBasedCacheInvalidation`. Реализация данного метода для должна использовать калькулятор устаревания элементов, доступный в  свойстве `ExpiryCalculator`.

Минимальный интервал между запусками инвалидации кэша установлен в 1 минуту. Если это почему-то является проблемой для вашей реализации, дайте мне знать.

В качестве бонуса, не предусмотренного в контракте поведения реализаций распределённого кэша Microsoft, данный инвалидатор кэша позволяет отследить момент начала и завершения инвалидации с помощью событий `CacheInvalidationStarted` и `CacheInvalidationCompleted` соответственно. Единственное ограничение, при выполнении данных событий не учитывается контекст синхронизации, то есть они не могут обновлять свойства элементов управления UI-фреймворков, таких как WPF или WinForms. Я не считаю это серьёзным ограничением, так как вывод подобной статистики на экран для меня является чем-то странным.